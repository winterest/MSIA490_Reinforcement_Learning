# -*- coding: utf-8 -*-
"""MSIA490_RL_HW1_Xiaoyi_Liu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XNq8IW86pyyZwQRAjJAYyft-25k0eSAo

# Problem 1
 Consider shuttle dispatching problem in which a dispatcher is responsible to decide whether or not to dispatch a shuttle at each decision epoch depending on number of customers waiting for the service. A standard shuttle dispatch problem has following parameters:

K = The capacity of a shuttle if it is dispatched. 

At = A random variable giving the number of customers arriving during time interval t. 

cf = The cost of dispatching a shuttle. 

ch = The cost per customer left waiting per time period.

Given K = 15, cf = 100, ch = 2 and assuming that At follows unif{1,5}, model the problem and solve it using:

a) Enumeration (with time period $T =500$) 

b) Value iteration ($T = \infty$) 

c) Policy iteration.

You can assume that number of people in station can not exceed 200 and discount rate Î³ = 0.95.

## Libraries
"""

import numpy as np
import matplotlib.pyplot as plt

"""## Constant"""

K = 15
c_f = 100
c_h = 2
gamma = 0.95
max_customer = 200

T = 500

"""## Rewards function"""

def r(s,a):
    """
    s: number of current waiting customer 0-max_customer
    a: if or not dispatch a shuttle {0,1}
    """
    return -(a*c_f + max(0,s-a*K)*c_h)

"""## Part (a) Enumeration

For part (a), plot optimal value function at time 0 versus number of customers waiting.
"""

V = np.zeros((T+2,max_customer+1)) # value function, size of [time, #customer]

for t in range(T,-1,-1):
    for s in range(max_customer+1):
        v_a = [0, 0]
        for a in [0,1]:
            s_next = [min(max_customer, max(s-a*K,0)+i) for i in range(1,6)]
            v_a[a] = r(s,a) + gamma * np.mean(V[t+1,s_next])
        V[t,s] = max(v_a)

plt.figure()
plt.plot(V[0, :])
plt.xlabel("number of customers")
plt.title("Enumeration: optimal value function at time 0")
plt.show()

"""## part (b)
For part (b), plot optimal value function versus number of customers waiting.
"""

max_iter = 1000
eps = 1e-6
interval = 100

V = np.zeros((2,max_customer+1)) # value iteration. [cur, next]

for i in range(max_iter):
    V[1] = V[0]
    for s in range(max_customer+1):
        v_a = [0, 0]
        for a in [0,1]:
            s_next = [min(max_customer, max(s-a*K,0)+i) for i in range(1,6)]
            v_a[a] = r(s,a) + gamma * np.mean(V[1,s_next])
        V[0,s] = max(v_a)
    if (np.linalg.norm(V[0]-V[1]) < eps):
        break
    if (i%interval == 0):
        print(i,np.linalg.norm(V[0]-V[1]))
        
print("Converged at #iteration = %d, residual = %f"%(i, np.linalg.norm(V[0]-V[1])))

plt.figure()
plt.plot(V[0, :])
plt.xlabel("number of customers")
plt.title("Value Iteration: optimal value function at time 0")
plt.show()

"""## part (c)
For part (c), plot optimal policy versus number of customers waiting.
"""

def prob(policy):
    P = np.zeros((max_customer+1, max_customer+1))
    for s in range(max_customer+1):        
        a = policy[s]
        idx = max(s-a*K, 0) + 1
        for i in range(5):
            P[s, min(max_customer, idx+i)] += 1/5
    return P

pi = np.zeros((2,max_customer+1)).astype(int)

for i in range(max_iter):
    P = prob(pi[0])
    R = np.zeros(max_customer+1)
    for s in range(max_customer+1):
        R[s] = r(s, pi[0,s])
    A = np.eye(max_customer+1) - gamma*P
    b = np.mat(R).transpose()
    V = np.array(np.linalg.solve(A, b).transpose())[0]
    
    pi[1] = pi[0]
    for s in range(max_customer+1):
        v_a = [0, 0]
        for a in [0, 1]:
            
            s_next = [min(max_customer, max(s-a*K,0)+i) for i in range(1,6)]
            v_a[a] = r(s,a) + gamma * np.mean(V[s_next])
            
        pi[0,s] = np.argmax(v_a)
    print(i, np.linalg.norm(pi[0]-pi[1]) )
    if np.linalg.norm(pi[0]-pi[1]) < eps:
        break
print("Converged at #iteration = %d, residual = %f"%(i, np.linalg.norm(pi[0]-pi[1])))

plt.figure()
#plt.scatter(enumerate([pi[0]]))
plt.plot(pi[0])
plt.xlabel("number of customers")
plt.ylabel("optimal policy")
plt.show()

print('optimal policy: ', policy)

plt.figure()
plt.plot(V)
plt.xlabel("number of customers")
plt.title("Policy Iteration: optimal value function at time 0")
plt.show()



"""# Problem 2

The differences from problem 1 are:
* There are 5 types of customers with $c_h = \{1,1.5,2,2.5,3\}$
* each type customer cannot exceed 100.
* K = 30.

## Due to the huge memory usage, I have to reduce two dimensions of this problem
"""

max_customer_each = 20  # this is reduced to 20 in order to speed up the computation
c_f = -100
c_h = [-1, -1.5, -2] 
K = 10
gamma = 0.95
num_types = len(c_h)   
num_states = pow(max_customer_each+1, num_types)  
T = 100

def reward(s, a):
    res = int(sum(a)>0) * c_f
    for i in range(num_types):
        res += max(s[i] - a[i], 0) * c_h[i]
    return res

# encode the states S[3,4,5,6,7] into 3*pow(101, 0) + 4*pow(101, 1) + ^ + 7*pow(101, 5)
num_states = pow(max_customer_each + 1,num_types)

def encode_list(list_state):
    state = 0
    for i in range(num_types):
        state += list_state[i] * pow(max_customer_each+1, i)
    return(state)

def decode_state(state):
    #state_tmp = state.copy()
    list_state = [0]*num_types
    for i in range(num_types):
        list_state[i] = state%(max_customer_each+1)
        state = state//(max_customer_each+1)
    return(list_state)


def available_action(s):
    res = [[0 for i in range(num_types)]]
    a = [0 for i in range(num_types)]
    for i in range(len(s)-1, -1, -1):
        if s[i] > 0:
            a[i] = min(K-sum(a), s[i])
            if sum(a) == K:
                break
    res.append(a)
    return res


def gen_next_states(s, a):
    res_ = []
    for i in range(num_types):
        res_.append(list(range(max(s[i]-a[i], 0)+1, max(s[i]-a[i], 0)+4)))    
    for i in range(num_types):
        for j in range(len(res_[i])):
            if res_[i][j] > max_customer_each:
                res_[i][j] = max_customer_each
    list_res = [a*pow(max_customer_each,2)+b*(max_customer_each+1)+c for a in res_[0] for b in res_[1] for c in res_[2]]
    return list_res

V = np.zeros((2,num_states))

for i in range(T, -1, -1):
    V[1] = V[0]
    for s in range(num_states):
        state_list = decode_state(s)
        possible_value = [0, 0]
        for action_idx in [0, 1]:
            a = available_action(state_list)[action_idx]
            next_state_idx = gen_next_states(state_list, a)
            possible_value[action_idx] = gamma*V[1,next_state_idx].mean() + reward(state_list, a)
        V[0,s] = max(possible_value)

plt.figure()
plt.plot(V[0])
plt.show()

"""## Part(b)"""

V = np.zeros((2,num_states))
max_iter = 500
eps = 1e-6 
interval = 100
for i in range(max_iter):
    V[1] = V[0]
    for s in range(num_states):
        state_list = decode_state(s)
        possible_value = [0, 0]
        for action_idx in [0, 1]:
            a = available_action(state_list)[action_idx]
            next_state_idx = gen_next_states(state_list, a)
            possible_value[action_idx] = gamma*V[1,next_state_idx].mean() + reward(state_list, a)
        V[0,s] = max(possible_value)
    if i % interval == 0:
        print(i, np.linalg.norm(V[0]-V[1]))
    if np.linalg.norm(V[0]-V[1]) < eps:
        break

plt.figure()
plt.plot(V[0])
plt.show()

"""## Part(c)"""

V = np.zeros((2,num_states))
pi = np.zeros(num_states)
max_iter = 500
interval = 10
for i in range(max_iter):
    V[1] = V[0]

    for s in range(num_states):
        state_list = decode_state(s)
        a_idx = pi[s]
        a = available_action(state_list)[int(a_idx)]
        next_state_idx = gen_next_states(state_list, a)
        next_value = gamma*V[1,next_state_idx].mean() + reward(state_list, a)
        V[0, s] = next_value
        
    for s in range(num_states):
        state_list = decode_state(s)
        possible_value = [0, 0]
        for a in [0, 1]:
            al = available_action(state_list)[a]
            next_state_idx = gen_next_states(state_list, al)
            possible_value[a] = gamma*V[0, next_state_idx].mean() + reward(state_list, al)
        pi[s] = np.argmax(possible_value)
    
    if i % interval == 0:
        print(i, np.linalg.norm(V[0]-V[1]))
    if np.linalg.norm(V[0]-V[1]) < 1e-6*np.sqrt(num_states):
        break

plt.figure()
plt.plot(pi)
plt.show()